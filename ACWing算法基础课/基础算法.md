---

---

## 1、快速排序----分治思想

### 基本思想

![image-20240709151959028](../images/image-20240709151959028.png)

## 2、归并排序----分治思想

### 基本思想

![image-20240709154442545](../images/image-20240709154442545.png)

## 3、二分

* 有单调性一定可以二分，如果没有单调性也有可能可以二分

### 3.1 整数二分

![image-20240709165705642](../images/image-20240709165705642.png)

### 3.2 浮点数二分



## 4、大整数操作----大整数的长度<= 10的6次幂

#### 1. 大整数存储----（大整数的个位在数组的0号元素，小端存储）

![image-20240710094036454](../images/image-20240710094036454.png)

#### 2. 计算---模拟人的运算

### 4.1 大整数加法

### 4.2 大整数减法---去除前导0

### 4.3 大整数乘法---去除前导0

### 4.4 大整数除法---去除前导0



## 5、前缀和

### 5.1 一维前缀和

原i：a<sub>1</sub>，a<sub>2</sub>，...，a<sub>n</sub>

前缀和：S<sub>i</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>i</sub>， s[0] = 0 

1. 如何求S<sub>i</sub> ?

```c++
for(i = 1, i <= n; i++)
    s[i] = s[i - 1] + a[i];
```

2. 前缀和的作用

> 快速计算数组a中的某段数的和，例如计算a[i] ~ a[j]的和
>
> 如果循环来做，时间复杂度为O(N)；
>
> 利用前缀和，可以做到O(1)：S[j] - S[i - 1]

### 5.2 二维前缀和

S\[i][j]是左上角所有元素的和，其公式为：S\[i][j] = S\[ i -1 ][ j ] + S\[ i ][j - 1] - S\[ i-1 ][ j - 1] + a\[ i ][ j ]  

>给点给X<sub>1</sub>，Y<sub>1</sub>，X<sub>2</sub>，Y<sub>2</sub>，求：
>
>公式：==S\[X<sub>2</sub>][Y<sub>2</sub>] - S\[X<sub>2</sub>][Y<sub>1</sub> - 1] - S\[X<sub>1</sub> - 1][Y<sub>2</sub>] + S\[X<sub>1</sub>][Y<sub>1</sub>]==

![image-20240710110232790](../images/image-20240710110232790.png)

## 6、差分（前缀和逆运算）

###  6.1 一维差分

![image-20240710111246334](../images/image-20240710111246334.png)

### 6.2 二维差分

![image-20240710112038162](../images/image-20240710112038162.png)

## 七、双指针算法

## 八、位运算

### lowbit（x） = x & -x

返回x的最后一位1

例如：

>x = 1010，lowbit(x) = 10
>
>x = 101000，lowbit(x)  = 1000

==可求x的二进制的1的个数==



## 九、离散化

思想：==值域：0 ~ 10<sup>9</sup> ，将值域映射到10<sup>5</sup>内==

> 值域：a[ ]：		1，3，100，2000，50000	将其进行离散化
>
> ​           	   		  |     |        |           |              |
>
> 离散化后的下标 ：     0    1        2           3             4

具体步骤：

1. a[ ]中可能有重复元素，==要进行去重==

```c++
vector<int> alls;
...
sort(alls.begin(),alls.end());
alls.erase(unique(alls.begin, alls.end()), alls.end());
```

2. 如何计算出a[ i ]离散化后的值



## 十、区间合并

**思想**：给定一些区间，有些区间会有交集，==将有交集的区间进行合并==

如下图：

![image-20240711153604566](../images/image-20240711153604566.png)

**算法**：

1. 按照全歼的左端点进行排序

2. 遍历其中一个区间，会有一下三种情况

   ![image-20240711153955435](../images/image-20240711153955435.png)

